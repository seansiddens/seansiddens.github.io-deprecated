---
layout: page
title: Why Software Sucks
permalink: /why_software_sucks/
---


Our world is completely reliant on software. 
Many of our most critical systems, from airplane navigation to power plant shutdown procedures, are completely automated by software.
Code is the backbone of the world’s economy: processing trillions of transactions per day and powering many of the world’s most profitable platforms. 
This time in history, the information age, is defined by the rapid and complete takeover of software over the last few decades. 
Furthermore, this takeover is showing no signs of slowing down.
Software is only going to get bigger and control more of our world as time goes on. 
However, the quality of the software ruling our world is, in many cases, terrible, and it only seems to be getting worse. 


There are many ways to measure the “quality” of software. 
The [ISO 25010](https://iso25000.com/index.php/en/iso-25000-standards/iso-25010) standard models on a number of categories: performance efficiency, reliability, compatibility, security, usability, and maintainability.
These metrics pertain to the structural quality of a piece of software, meaning they measure how well the software supports the delivery of its functional requirements.
The functional quality of software relates to how well it meets its own functional specifications.
For example, a calculator app which incorrectly computes the addition of two and two to be five would fail to meet its own functional specifications: to correctly carry out arithmetic calculations.
Thus, the functional quality would be lacking.
However, if the source code was needlessly complicated and/or obfuscated, or the application had a security vulnerability, then the software would be suffering from poor structural quality (namely in maintainability and security).
However, these two conceptions of quality are often closely related, due to the fact that poor structural quality often directly leads to a software “bug”: a defect in the software, produced by human error, which ultimately results in the failure of the software to carry out its intended purpose.
In our calculator example, poor structural quality could lead to a bug which results in the application crashing whenever you wish to subtract two numbers, and thus would fail to meet its own functional specifications.
The functional quality of a piece of software is often directly related to its own structural quality, and thus the two terms are often simply referred to under the umbrella term “software quality”.
